#-----------------------------------------------------------------------------
#  S3 implementation of BIOM format version 1.0
#
#  BIOM format constitutes a simple standard for annotation of a two-dimensional
#  matrix:  http://biom-format.org/documentation/format_versions/biom-1.0.html.
#  We implement a corresponding "biom" class: a regular R matrix contained in a
#  list of annotations.  We offer validation, conversion, and a few other methods.
#
#  These objects have class(x) equal to c("biom", "list").
#-----------------------------------------------------------------------------


##############################################################################
##############################################################################
##
##  BASIC CLASS UTILITIES
##
##############################################################################
##############################################################################

#-----------------------------------------------------------------------------
#  a slightly prettified version of str.default(),
#  tailored to our objects.
#-----------------------------------------------------------------------------

str.biom <- function (object, ...) {
	str (unclass (object) [c(
			"rows",
			"columns",
			"data",
			"shape",
			"matrix_type",
			"matrix_element_type",
			"type",
			"format",
			"format_url",
			"date",
			"id",
			"generated_by")],
		vec.len=1, nchar.max=35, strict.width="wrap", give.attr=FALSE, list.len=12, ...)
	}

#-----------------------------------------------------------------------------
#  summary() omits showing the matrix data,
#  but shows all other contents of the object.
#-----------------------------------------------------------------------------

summary.biom <- function (object, ...) { 
	dims <- paste (dim (object), collapse="x")
	xx <- with (object, { paste(
		"identifier: ", id,
		"\ngenerated by: ", generated_by, " on ", date, "\n",
		matrix_type, " ", type, " (", dims, ")\n", 
		format, "\n", sep="") })
	class (xx) <- c("biomsummary", "character")
	xx
	}

#-----------------------------------------------------------------------------
#  summary() canonically returns a classed object with its own print() method.
#  print() canonically returns invisibly the object printed.
#-----------------------------------------------------------------------------

print.biomsummary <- function (x, ...) {
	cat (x)
	invisible (x)
	}

#-----------------------------------------------------------------------------
#  print() shows the full contents of the object,
#  including the matrix data.
#-----------------------------------------------------------------------------

print.biom <- function (x, ...) {
	print (as.matrix (x))
	print (summary (x))
	invisible (x)
	}

#-----------------------------------------------------------------------------
#  dim() gives shape of the matrix (whether or not sparse)
#-----------------------------------------------------------------------------

dim.biom <- function (x) {
	dim (x$data)
	}

#-----------------------------------------------------------------------------
#  and dimnames().
#  we implement neither rownames() nor colnames() here.
#  they are not already generic, and to resolve that properly moves 
#  outside the concept of this package to be as simple as possible.
#-----------------------------------------------------------------------------

dimnames.biom <- function (x) {
	dimnames (x$data)
	}

rows <- function (x) {
	x$rows
	}

columns <- function (x) {
	x$columns
	}


##############################################################################
##############################################################################
##
##  CONVERSION FROM
##
##############################################################################
##############################################################################

#-----------------------------------------------------------------------------
#  our representation already contains the "matrix" just as is,
#  so here we simply extract the list component.
#-----------------------------------------------------------------------------

as.matrix.biom <- function (x, ...) {
	x$data
	}

#-----------------------------------------------------------------------------
#  "biom" objects are already "list"s, so 
#  removing the class attribute is enough to convert
#-----------------------------------------------------------------------------

as.list.biom <- function (x, ...) {
	unclass (x)
	}

#-----------------------------------------------------------------------------
#  conversion to JSON text requires:
#    -conform 'rows' and 'columns' by adding ID field
#    -for 'dense', write out list of rows, so to speak, verbatim
#    -for 'sparse', write out (row,column,value) triples
#-----------------------------------------------------------------------------

as.character.biom <- function (x, ...) {
	library(RJSONIO)
	x$rows <- mapply (function (xx, yy) list (id=xx, metadata=yy),
		as.list (rownames (x$data)),
		x$rows)
	x$columns <- mapply (function (xx, yy) list (id=xx, metadata=yy),
		as.list (colnames (x$data)),
		x$columns)
	x$data <-
		if (x$matrix_type == "dense") {
			apply (x$data, 1, as.list)
		} else {
			ss <- which (x$data != 0, arr.ind=TRUE)
			rr <- t (mapply (function (i, j, m) c (i, j, m [i,j]),
				ss [,1], ss[,2], MoreArgs = list (x$data)))
			rr [,1] <- rr[,1] - 1
			rr [,2] <- rr[,2] - 1
			apply (rr, 1, as.list)
		}
	toJSON (x, pretty=TRUE, ...)
	}


##############################################################################
##############################################################################
##
##  CONSTRUCTORS
##
##############################################################################
##############################################################################

biom <- function (x, ...) UseMethod("biom")

#-----------------------------------------------------------------------------
#  here we expect and require fromJSON() to return an appropriate list.
#  see below for biom.list().
#-----------------------------------------------------------------------------

biom.character <- function (x, ..., file = NULL, quiet = FALSE) {
	library(RJSONIO)
	if (!is.null (file)) x <- readLines (file, warn=!quiet)
	biom (fromJSON (x, asText=TRUE, simplify=TRUE), quiet=quiet)
	}

#-----------------------------------------------------------------------------
#  from matrix, just invent something appropriate for all fields.
#  use mode(mm) <- 'integer' to force matrix_element_type == 'int'
#-----------------------------------------------------------------------------

biom.matrix <- function (x, type = biom_table_types, ..., quiet = FALSE) {
	if (quiet) warning <- function (...) { }
	if (missing (type)) {
		warning ("arbitrary default for missing \'type\'")
		}
	if (is.null (rownames (x))) {
		warning ("rownames should provide row \'id\'s but are missing")
		rownames(x) <- 1:nrow(x)
		}
	if (is.null (colnames (x))) {
		warning ("colnames should provide column \'id\'s but are missing")
		colnames(x) <- 1:ncol(x)
		}
	y <- list()
	y$type <- match.arg (type)
	y$data <- x
	y$shape <- dim (x)
	y$rows <- replicate (nrow(x), character(0))
	y$columns <- replicate (ncol(x), character(0))
	y$matrix_type <- "dense"
	y$matrix_element_type <-
		if (is.integer (x)) {
			"int"
		} else if (is.numeric (x)) {
			"float"
		} else
			"unicode"
	is.biom (y, fix=TRUE, quiet=quiet)
	}

#-----------------------------------------------------------------------------
#  allow an empty list here.
#  (it would not be fixed by is.biom().)
#  is.biom() would fix the "class", but we would like to avoid a warning
#-----------------------------------------------------------------------------

biom.list <- function (x, ..., quiet = FALSE) { 
	if (quiet) warning <- function (...) { }
	if (is.null (x$data)) {
		warning ("object is empty and of arbitrary type")
		x <- list (
			rows = list(),
			columns = list(),
			data = list(),
			shape = c(0,0),
			matrix_type = "dense",
			matrix_element_type = "unicode",
			type = biom_table_types [1],
			format = "Biological Observation Matrix 1.0",
			format_url = "",
			date = strftime (Sys.time()),
			id = "",
			generated_by = 
				paste("BIOM.utils (", packageVersion("BIOM.utils"), ")", sep=""))
		class (x) <- c("biom", "list")
		return (x)
		}
	class (x) <- c("biom", class (x))
	is.biom (x, fix=TRUE, quiet=quiet)
	}


##############################################################################
##############################################################################
##
##  OBJECT VALIDATION
##
##############################################################################
##############################################################################

is.biom <- function (x, fix=FALSE, check.all=fix, quiet=!check.all) {
	if (quiet) warning <- function (...) { }

#-----------------------------------------------------------------------------
#  warn of conflics
#-----------------------------------------------------------------------------
	if ("package:biom" %in% search())
		warning ("related package \"biom\" is loaded and may cause conflicts")

#-----------------------------------------------------------------------------
#  object must be "list" already
#  adjust class to treat as list throughout
#-----------------------------------------------------------------------------
	if (!is.list (x)) {
		warning ("object is not list")
		if (!fix) return (FALSE) else stop ("cannot fix")
		}
	cl <- class (x)
	x <- unclass (x)

#-----------------------------------------------------------------------------
#  list components must be named
#-----------------------------------------------------------------------------
	if (is.null (names (x))) {
		warning ("components are unnamed")
		if (!fix) return (FALSE) else stop ("cannot fix")
		}

#-----------------------------------------------------------------------------
#  extraneous fields produce a warning but not failure;
#  duplicate fields produce failure but can be fixed;
#  if need be, remove extraneous and duplicate fields
#-----------------------------------------------------------------------------
	if (!all (belong <- names(x) %in% biom_fields))
		warning ("extraneous field(s): ", collapse (names (x) [!belong]))

	if (any (dups <- table (names(x)) > 1)) {
		warning ("duplicate fields: ", collapse (names (x) [dups]))
		if (!fix) return (FALSE)
		}
	x <- x [biom_fields [have <- biom_fields %in% names(x)]]
	
#-----------------------------------------------------------------------------
#  note missing fields;
#  fail if impossible to recover;
#  but otherwise make simple corrections right away
#-----------------------------------------------------------------------------
	missing <- biom_fields [!have]
	if (length (missing)) {
		warning ("missing field(s): ", collapse (missing))
		if (!fix) return (FALSE)
		if ("data" %in% missing) stop ("cannot fix without \"data\"")

		if ("id" %in% missing) 				x$id <- ""
		if ("format" %in% missing)			x$format <- "Biological Observation Matrix 1.0"
		if ("format_url" %in% missing)		x$format_url <- ""
		if ("generated_by" %in% missing)	x$generated_by <- 
			paste("BIOM.utils (", packageVersion("BIOM.utils"), ")", sep="")
		if ("date" %in% missing)			x$date <- strftime(Sys.time())
		if ("matrix_element_type" %in% missing)		x$matrix_element_type <- "unicode"
		if ("matrix_type" %in% missing)		x$matrix_type <- "dense"
		if ("type" %in% missing)			x$type <- biom_table_types [1]
		if ("rows" %in% missing)			x$rows <- replicate (nrow(x), character(0))
		if ("columns" %in% missing)			x$columns <- replicate (ncol(x), character(0))
		}		

#-----------------------------------------------------------------------------
#  check controlled vocabs (type, matrix_element_type, matrix_type)
#-----------------------------------------------------------------------------
	if (! (x$type %in% biom_table_types)) {
		warning ("invalid \"type\": ", x$type)
		if (!fix) return (FALSE)
		if (is.na (k <- pmatch (x$type, biom_table_types))) stop("cannot fix") else 
			x$type <- biom_table_types[k]
		}
	if (! (x$matrix_element_type %in% biom_element_types)) {
		warning ("invalid \"matrix_element_type\": ", x$matrix_element_type)
		if (!fix) return (FALSE) 
		if (is.na (k <- pmatch (x$matrix_element_type, biom_element_types))) stop("cannot fix") else 
			x$matrix_element_type <- biom_element_types[k]
		}
	if (! (x$matrix_type %in% biom_matrix_types)) {
		warning ("missing or bad \"matrix_type\": ", x$matrix_type)
		if (!fix) return (FALSE)
		if (is.na (k <- pmatch (x$matrix_type, biom_matrix_types))) stop("cannot fix") else 
				x$matrix_type <- biom_matrix_types[k]
		}

#-----------------------------------------------------------------------------
#  allow for fixing 'data' given as 'list' (to be 'matrix' instead)
#  a flag allows removal of "id" from metadata later
#-----------------------------------------------------------------------------  
	waslist <- FALSE
	if (is.list (x$data)) {
		waslist <- TRUE
		warning ("data is given as \"list\"")
		if (!fix) return (FALSE)

		mm <- x$data <- t (simplify2array (x$data))
		if (class (mm) != "matrix") stop ("malformed \"data\" list does not simplify to matrix")
#-----------------------------------------------------------------------------  
#  sparse and dense cases are different
#  we require sparsity to be explicit (from the user)
#-----------------------------------------------------------------------------  
		if (x$matrix_type == "sparse") {
			if ("shape" %in% missing) stop ("cannot fix sparse list data without \"shape\"")
			di <- x$shape
			mm [,1:2] <- mm [,1:2] + 1
			colnames (mm) <- c("row", "col", "value")
#-----------------------------------------------------------------------------  
#  reshape used instead of Matrix package (for speed)
#-----------------------------------------------------------------------------  
			df <- reshape (data.frame(mm), v.names="value", idvar="row", timevar="col", direction="wide")
#-----------------------------------------------------------------------------  
#  entire rows / columns of zero will be missing
#  so convert the reshaped data to proper dims
#-----------------------------------------------------------------------------  
			mm <- matrix (NA, nrow = di[1], ncol = di[2])
			cols <- paste ("value", 1:ncol(mm), sep=".")
			j <- cols %in% names(df)
			mm [df$row, j] <- as.matrix (df [ , cols[j]])
			mm [is.na (mm)] <- 0
			x$data <- mm
			}
		}

#-----------------------------------------------------------------------------
#  now that we know 'data' is a matrix, can assign 'shape', if missing
#-----------------------------------------------------------------------------
	if ("shape" %in% missing) x$shape <- dim (x$data)

#-----------------------------------------------------------------------------
#  check has row and col names (to serve as ids)
#-----------------------------------------------------------------------------
	if (is.null (rownames (x$data))) {
		warning ("\"data\" has no rownames")
		if (!fix) return (FALSE) else rownames(x$data) <- 1:nrow(x$data)
		}

	if (is.null (colnames (x$data))) {
		warning ("\"data\" has no colnames")
		if (!fix) return (FALSE) else colnames(x$data) <- 1:ncol(x$data)
		}

	if (!check.all && !fix) return (TRUE)

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
#  here marks the separation between a "short" and "long" conformity check.
#  long check: consistency of data description (data, shape, rows, columns)
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
#  check accuracy of shape
#-----------------------------------------------------------------------------
	if (! identical (dim (x$data), x$shape)) {
		warning ("incorrect shape")
		if (!fix) return (FALSE) else x$shape <- dim (x$data)
		}
#-----------------------------------------------------------------------------
#  if waslist, use "ids" from metadata for rownames and colnames, and remove
#-----------------------------------------------------------------------------
	if (waslist) {
		rownames (x$data) <- sapply (rows, `[[`, "id")
		colnames (x$data) <- sapply (columns, `[[`, "id")
		rows <- sapply (rows, `[[`, "metadata")
		columns <- sapply (columns, `[[`, "metadata")
# need repetitive check here, or something
		}
#-----------------------------------------------------------------------------
#  check metadata, simply
#-----------------------------------------------------------------------------
	if(!is.list (x$rows) || 
		!is.list (x$columns) ||
		length (x$rows) != x$shape[1] || 
		length (x$columns) != x$shape[2]) {
		warning ("incorrect length of \"rows\" and/or \"columns\"")
		if(!fix) return(FALSE) else stop("cannot fix")
		}

#-----------------------------------------------------------------------------
#  standardize order of elements
#-----------------------------------------------------------------------------
	x <- x [biom_fields]

#-----------------------------------------------------------------------------
#  finally, restore class of x 
#  and add "biom" class if missing
#-----------------------------------------------------------------------------
	class (x) <- cl
	if (! (inherits (x, "biom"))) {
		warning ("not biom class")
		if (!fix) return (FALSE) else class(x) <- c("biom", class(x))
		}

#-----------------------------------------------------------------------------
#  maybe a final sanity check? (...actually, the class definition)
#-----------------------------------------------------------------------------
# 	if (inherits (x, "biom")
# 		&& inherits (x, "list")
# 		&& identical (names (x), biom_fields)
# 		&& identical (sapply (x, length), ...)
# 		&& identical (sapply (x, class), ...)
# 		&& !is.null (rownames (x$data))
# 		&& !is.null (colnames (x$data))
# 		&& length (x$rows) == x$shape [1]
# 		&& length (x$columns) == x$shape [2])

	return (if (fix) x else TRUE)

	warning ("unidentified error") 
	if (fix) stop ("cannot fix") else return (FALSE)
	}


##############################################################################
##############################################################################
##
##  PACKAGE UTILITIES
##
##############################################################################
##############################################################################

#-----------------------------------------------------------------------------
#  This routine build the package example data:
#
#  BIOM.utils/data/examples.rda:
#		jtxt -- complete JSON text for BIOM object
#		smat -- sparse matrix of data, represented in three columns
#		dmat -- dense matrix, with row and column names
#		li1 -- minimal list, with data given as dense matrix with dimnames
#		li2 -- short list, data as above, but also with explicit row and column records
#		li3 -- short list as above, but with data formatted as list of rows
#		li4 -- complete list of BIOM components
#
#  BIOM.utils/inst/extdata/example-file.txt:
#		JSON text for a biom object
#
#-----------------------------------------------------------------------------

buildBiomExamples <- function(outfile.Rda="examples.rda", outfile.txt="example-file.txt") {
	library (RJSONIO)
	library (MGRASTer)
	triple <- function (x) paste(x, x, x, sep="")

	jtxt <- call.MGRAST ('ma', 'or', id=c(4447943.3, 4447192.3, 4447102.3, 4447103.3), 
		gro='family', so='Ref', resu='ab', ev=15, parse=FALSE, debug=FALSE)
	writeLines(jtxt, "example-file.txt")
	message ("Built ", outfile.txt, " in: ", getwd(), ".  Move to BIOM.utils/inst/extdata")

	dmat <- matrix(101:200, nrow=20, dimnames=list(letters[1:20], LETTERS[1:5]))
	li1 <- list(
		data=dmat,
		type="OTU")
	li2 <- list(
		data = dmat,
		type = "OTU table",
		rows = lapply(triple(rownames(dmat)),
			function (x) c(id=x, metadata=paste("metadata of", x))),
		columns = lapply(triple(colnames(dmat)),
			function (x) c(id=x, metadata=paste("metadata of", x))))
	li3 <- list(
		data=lapply(apply(unname(dmat), 1, list), `[[`, 1),
		type="OTU table",
		rows=li2$rows,
		columns=li2$columns)
	li4 <- call.MGRAST ('ma', 'or', id=c(4447943.3, 4447192.3, 4447102.3, 4447103.3), 
		gro='family', so='Ref', resu='ab', ev=15, debug=FALSE)
	li4 [c("matrix_element_value", "url")] <- NULL
	smat <- t(simplify2array(li4$data))

	save(smat, dmat, li1, li2, li3, li4, jtxt, file=outfile.Rda)
	message ("Built ", outfile.Rda, " in: ", getwd(), ".  Move to BIOM.utils/data")
	}

#-----------------------------------------------------------------------------
#  routine simply to apply all biom functions to an object.
#  for testing.
#-----------------------------------------------------------------------------

applyBiomMethods <- function (x) {
	str(x)
	as.character(x)
	as.matrix(x)
	dim(x)
	dimnames(x)
	print(x)
	summary(x)
	is.biom(x)
	is.biom(x,fix=TRUE)
	}

#-----------------------------------------------------------------------------
#  return a the example file of JSON text.
#  biom.character() may be applied to it.
#-----------------------------------------------------------------------------

exampleBiomFile <- function () {
	file.path (path.package ("BIOM.utils"), "extdata", "example-file.txt")
	}


##############################################################################
##############################################################################
##
##  LITTLE STUFF  (unexported)
##
##############################################################################
##############################################################################

#-----------------------------------------------------------------------------
#  we give warnings in a slightly idiosyncratic way
#-----------------------------------------------------------------------------

warning <- function (...) base::warning ("BIOM.utils: ", ...,  call.=FALSE)

#-----------------------------------------------------------------------------
#  concatenate things with spaces between
#-----------------------------------------------------------------------------

collapse <- function (x) paste (x, collapse=" ", sep="")

#-----------------------------------------------------------------------------
#  to report github commit at startup, preprocess this source with:
#    sed s/XXXBUILDXXX/$commit/g matR/R/init.R > init.Rtemp
#    mv init.Rtemp matR/R/init.R
#-----------------------------------------------------------------------------

.onAttach <- function (libname, pkgname) { 
	ss <- " build XXXBUILDXXX"
	if (substr (ss, 8, 15) == "XXXBUILD") ss <- ""
	packageStartupMessage(pkgname, " (", packageVersion(pkgname), ss, ")")
	}
