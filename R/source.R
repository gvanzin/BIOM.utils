################################################################################
##  Issues:
##  help is out of date
##    note that "is.biom" allows nonstandard elements and superclasses
##    fix examples (take from tests)
##  more thorough pkg description: think, outside perspective; professional
##  optional "comment" field has been systematically overlooked
##  revisit check of "rows" and "columns" in "is.biom"
##  how to get package name in a better way
##  warning message lacking callbacks should indicate provenance: "biom missing field(s):"
##
##  Ideas:
##  store data as matrix internally
################################################################################

######################################################################################
## S3 implementation of BIOM format
## http://biom-format.org/documentation/format_versions/biom-1.0.html
## class(x) is c("biom", "list")
##
## BIOM required components: 
## id, format, format_url, type, generated_by, date, rows, columns, matrix_type, matrix_element_type, shape, data
##
## BIOM optional components: 
## comment
##
## package includes validation, conversion, and other utility methods
## small on purpose, no bloat
######################################################################################

.onAttach <- function (libname, pkgname) { 
	packageStartupMessage(pkgname, " (", packageVersion(pkgname), " build xxxxxxx)")
}

######################################################################################
## a slight tweak of str.default()
######################################################################################
str.biom <- function (object, ...) {
	str(unclass(object) [c("rows", "columns", "data", "shape", "matrix_type", "matrix_element_type",
		"type", "format", "format_url", "date", "id", "generated_by")],
	vec.len=1, nchar.max=35, strict.width="wrap", give.attr=FALSE, list.len=12, ...)
}

######################################################################################
## print() shows everything
######################################################################################
print.biom <- function (x, ...) {
	print(as.matrix(x))
	cat('\n')
	print(summary(x))
#-------"print" canonically returns the object printed, invisibly
	invisible(x)
}

######################################################################################
## summary() omits showing the matrix data
######################################################################################
summary.biom <- function (object, ...) { 
	dimstr <- paste(dim(object), collapse="x")
	if (object$matrix_type == "sparse")
		dimstr <- paste (len(object), "entries,", dimstr)
	ret <- paste("identifier: ", object$id, "\n", 
		"generated by: ", object$generated_by, " on ", object$date, "\n", 
		object$matrix_type, " ", object$type, " (", dimstr, ") ", object$format, "\n", sep="")
#-------"summary" canonically returns a "summary" object that has its own "print" method
	class(ret) <- c("biomsummary", "character")
	ret
}

#-------see comment just above
print.biomsummary <- function(x, ...) {
	cat(x)
	invisible(x)
}

######################################################################################
## number of actually provided data elements
## note the subtlety in counting, here, according to whether sparse or dense
######################################################################################
len <- function(x) {
	if(x$matrix_type == "sparse")
		length(x$data)
	else {
		message("Note: biom object is not sparse")
		length(unlist(x$data))
		}
}

######################################################################################
## shape of matrix (whether or not sparse)
######################################################################################
dim.biom <- function(x) {
	as.integer(unlist(x$shape))
}

######################################################################################
## default "namer" functions for rows and columns...
## "extractors" from the object's row and column tags
## have to take a bit of trouble to be bulletproof, here
######################################################################################
byid <- function (x) {
	as.character(x["id"]) [1]
}

bymetadata <- function (x) {
	paste(unlist(x["metadata"]), collapse=",")
}

######################################################################################
## returns length-2 list of rownames, colnames
## good to have methods for those functions, too
## but would be asking for trouble (for now) since they are not already generic
## ...whereas dimnames() is
## this function always provides the output of byid()
######################################################################################
dimnames.biom <- function(x) {
	list(sapply (x$rows, byid),
		sapply (x$columns, byid))
}

######################################################################################
## convert to matrix
## only load the (bulky) Matrix package if the user really wants it to handle sparse case
## some contortions with "reshape" are necessary in case of highly sparse data
## here, user-provided row- and column-name extractor functions are allowed
######################################################################################
as.matrix.biom <- function(x, rownamer=byid, colnamer=byid, force.dense=TRUE, ...) {
	di <- dim(x)
#-------case of sparse format
	if (x$matrix_type == "sparse") {
		mm <- t(simplify2array(x$data))
		if (force.dense) {
			mm[,1:2] <- mm[,1:2] + 1
			colnames(mm) <- c("row", "col", "value")
#-------reshape used instead of Matrix package
			df <- reshape(data.frame(mm), v.names="value", idvar="row", timevar="col", direction="wide")
#-------entire rows and/or columns might be missing if all zero
#-------so conversion of the reshaped sparse data to a matrix of proper size is delicate
			mm <- matrix(NA, nrow=di[1], ncol=di[2])
			cols <- paste("value", 1:ncol(mm), sep=".")
			j <- cols %in% names(df)
			mm[df$row, j] <- as.matrix(df[,cols[j]])
			mm[is.na(mm)] <- 0
#-------case of dense format
		} else
			mm <- Matrix::sparseMatrix (i=1+mm[,1], j=1+mm[,2], x=mm[,3], dims=di)
	} else
		mm <- matrix (unlist (x$data), nrow=di[1], ncol=di[2], byrow=TRUE)
	dimnames(mm) <- list(
		sapply(x$rows, rownamer),
		sapply(x$columns, colnamer))
	mm
}

######################################################################################
## convert to JSON text
##--->the use of toJSON() here needs some careful looking-over
######################################################################################
as.character.biom <- function (x, ...) {
	RJSONIO::toJSON(x, pretty=TRUE, ...)
}

######################################################################################
## CONSTRUCTORS
######################################################################################
biom <- function (x, ...) UseMethod("biom")

######################################################################################
## construct from list
######################################################################################
#-------change default to quiet=TRUE for prod
biom.list <- function (x, quiet=FALSE, ...) { 
#-------is.biom() would fix the "class" but here we avoid the warning message
	class(x) <- c("biom", class(x))
	is.biom(x, fix=TRUE, quiet=quiet)
}

######################################################################################
## construct from matrix, inventing something for all fields appropriately
######################################################################################
#-------change default to quiet=TRUE for prod
biom.matrix <- function (x, 
	type = c("OTU table","Pathway table","Function table","Ortholog table",
		"Gene table","Metabolite table","Taxon table"), quiet=FALSE, ...) {
#-------no way to infer if "type" is missing
	if(missing(type))
		stop("parameter \"type\" is required")
#-------must create row and column identifiers if not provided
	if(is.null(rownames(x))) rownames(x) <- 1:nrow(x)
	if(is.null(colnames(x))) colnames(x) <- 1:ncol(x)

	y <- list()
	y$type <- match.arg(type)
	y$data <- apply(x, 1, as.list)
#-------don't know how character(0) will be converted back to JSON
	y$rows <- lapply(rownames(x), function(y) list(id=y, metadata=character(0)))
	y$columns <- lapply(colnames(x), function(y) list(id=y, metadata=character(0)))
	y$matrix_type <- "dense"
#->-----this really might be wrong; look into it
	y$matrix_element_type <- "unicode"
	y$shape <- dim(x)
	is.biom(y, fix=TRUE, quiet=quiet)
}

######################################################################################
## construct from JSON text
######################################################################################
biom.character <- function (x, ...) {
#-------the use of fromJSON() here needs some careful looking-over
	biom(RJSONIO::fromJSON(x, asText=TRUE, simplify=TRUE))
}

######################################################################################
## validate object
##--->shape should be integer, character, or list??
##--->should check matrix_element_type
######################################################################################
is.biom <- function (x, fix=FALSE, check.all=fix, quiet=!check.all) {
	qwarning <- if (quiet) function(...) { } else function (...) warning(..., call.=FALSE)
	collapse <- function (x) paste(x, collapse=" ", sep="")

#-------constants of BIOM format
	fields <- c("rows", "columns", "data", "shape", "matrix_type", "matrix_element_type",
		"type", "format", "format_url", "date", "id", "generated_by")
	mandatory <- c("type","rows","columns","data")
	types <- c("OTU table","Pathway table","Function table","Ortholog table",
		"Gene table","Metabolite table","Taxon table")

	if("package:biom" %in% search())
		warning("redundant package \"biom\" is loaded and may cause conflicts")

#-------must be "list" already
	if(!is.list(x)) {
		qwarning("object is not list")
		if(!fix) return(FALSE)
		else stop("cannot fix")
	}

#-------must also be named
	if(is.null(names(x))) {
		qwarning("components are unnamed")
		if(!fix) return(FALSE)
		else stop("cannot fix")
	}

#-------check for present and missing fields; note a name may appear more than once

#-------extraneous fields produce a warning but not return(FALSE)
	belong <- names(x) %in% fields
	if(!all(belong))
		qwarning("contains extraneous field(s): ", collapse(names(x)[!belong]))
#-------duplicate fields can be fixed, but are disqualifying in principle
	dups <- table(names(x)) > 1
	if(any(dups)) {
		qwarning("contains duplicate fields: ", collapse(names(x)[dups]))
		if(!fix) return(FALSE)
		}

#-------"data" should be a "list" of rows, but we accommodate "matrix" also
#-------use rownames and/or colnames if "rows" and/or "columns" records are missing
	if(class(x$data) == "matrix") {
		if(!is.null(rownames(x$data)) && !("rows" %in% names(x))) {
			x$rows <- lapply(rownames(x$data),
				function (y) list(id=y, metadata=character(0)))
				qwarning("using rownames to generate \"rows\"")
			}
		if(!is.null(colnames(x$data)) && !("columns" %in% names(x))) {
			x$columns <- lapply(colnames(x$data),
				function (y) list(id=y, metadata=character(0)))
				qwarning("using colnames to generate \"columns\"")
			}
		tmp <- apply(x$data, 1, as.list)
		x$data <- lapply(tmp, unlist)
		}

#-------remove both.  need workaround here to preserve class attribute of x
	have <- fields %in% names(x)
	cl <- class(x)
	x <- x[fields [have]]
	class(x) <- cl

#-------missing fields can sometimes be fixed
	fields.missing <- fields[!have]
	if(length(fields.missing)) {
		qwarning("field(s) missing: ", collapse(fields.missing))
		if(!fix) return(FALSE)
#-------require the most basic info
		if(any(mandatory %in% fields.missing))
			stop("cannot fix without: ", collapse(mandatory))
#-------fill in trivial basic info
		if("id" %in% fields.missing) x$id <- "NA"
		if("format" %in% fields.missing) x$format <- "NA"
		if("format_url" %in% fields.missing) x$format_url <- "NA"
#->-----DON'T LIKE THIS:
		if("generated_by" %in% fields.missing) x$generated_by <- 
			paste("BIOM.utils", " (", packageVersion("BIOM.utils"), " build xxxxxxx)", sep="")
		if("date" %in% fields.missing) x$date <- strftime(Sys.time())
	}

#-------check controlled vocabulary for "type" (which we confirmed is present)
	if(! (x$type %in% types)) {
		qwarning("invalid \"type\": ", x$type)
		if (!fix) return(FALSE)
		k <- pmatch(x$type, types)
		if(is.na(k)) stop("cannot fix")
		else x$type <- types[k]
	}

#-------check CV for "matrix_element_type" (which may be absent)
	if(!length(x$matrix_element_type) || 
		!any(x$matrix_element_type == c("int", "float", "unicode"))) {
		qwarning("missing or bad \"matrix_element_type\": ", x$matrix_element_type)
		if(!fix) return(FALSE)
		else x$matrix_element_type <- "unicode"
		}

#-------check CV for "matrix_type" (which may be absent)
	if(!length(x$matrix_type) || 
		!any(x$matrix_type == c("sparse","dense"))) {
		qwarning("missing or bad \"matrix_type\": ", x$matrix_type)
		if(!fix) return(FALSE)
		else x$matrix_type <- NULL
		}

#-------check (only) that "shape" is present
	if(!length(x$shape)) {
		qwarning("missing \"shape\"")
		if(!fix) return(FALSE)
		else x$shape <- NULL
	}

#-------try to fix "shape" and/or "matrix_type"
	if(is.null(x$matrix_type) || is.null(x$shape)) {
		qwarning("inferring \"matrix_type\" and/or \"shape\"")
		if(all(sapply(x$data,length)==3)) {
			qwarning("assuming three-column data is sparse without knowing")
			x$matrix_type <- "sparse"
			x$shape <- c(max(sapply(x$data,`[[`,1)), max(sapply(x$data,`[[`,2))) + 1
		}
		else {
			x$matrix_type <- "dense"
			x$shape <- c(length(x$data), length(x$data[[1]]))
		}
	}

#-------here marks the separation between a "short" and "long"  conformity check
	if(!check.all && !fix) return(TRUE)

#-------check consistency of data and shape
	if(x$matrix_type == "dense") {
		ll <- length(x$data[[1]])
		if(!all(sapply(x$data,length)==ll)) {
			qwarning("non-uniform row lengths in dense matrix")
			if(!fix) return(FALSE)
			else stop("cannot fix")
		}
		if(!identical(x$shape, c(length(x$data), ll))) {
			qwarning("given \"shape\" is incorrect (for dense matrix)")
			if(!fix) return(FALSE)
			x$shape <- c(length(x$data), ll)
		}
	}
	else {
		if(!all(sapply(x$data,length)==3)) {
			qwarning("row lengths in sparse matrix not all three")
			if(!fix) return(FALSE)
			else stop("cannot fix")
		}
		maxrow <- max(sapply(x$data,`[[`,1)) + 1
		maxcol <- max(sapply(x$data,`[[`,2)) + 1
		if(x$shape[[1]] < maxrow || x$shape[[2]] < maxcol) {
			qwarning("given \"shape\" is incorrect (for sparse matrix)")
			if(!fix) return(FALSE)
			x$shape <- c(maxrow, maxcol)
		}
	}

#-------check for a record per row and column
	if(length(x$rows) != x$shape[1] || length(x$columns) != x$shape[2]) {
		qwarning("incorrect number of row or column records")
		if(!fix) return(FALSE)
		else stop("cannot fix")
	}

#->-----the checks below could check the format more exactly
#->-----also, uniqueness of row and column IDs should be checked

#-------check rows
	zz <- !sapply(x$rows, function (y) "metadata" %in% names(y))
	if(any(zz)) {
		qwarning("row(s) missing \"metadata\": ", which(zz))
		if(!fix) return(FALSE)
		x$rows[zz] <- lapply(x$rows[zz], `[[<-`, "metadata", character(0))
	}
	zz <- !sapply(x$rows, function (y) "id" %in% names(y))
	if(any(zz)) {
		qwarning("row(s) missing \"id\": ", which(zz))
		if(!fix) return(FALSE)
		else stop("cannot fix")
	}
#-------check columns
	zz <- !sapply(x$columns, function (y) "metadata" %in% names(y))
	if(any(zz)) {
		qwarning("column(s) missing \"metadata\": ", which(zz))
		if(!fix) return(FALSE)	
		x$columns[zz] <- lapply(x$columns[zz], `[[<-`, "metadata", character(0))
	}
	zz <- !sapply(x$columns, function (y) "id" %in% names(y))
	if(any(zz)) {
		qwarning("column(s) missing \"id\": ", which(zz))
		if(!fix) return(FALSE)
		else stop("cannot fix")
	}

#-------standardize order of elements.  need workaround here to preserve class attribute of x
	cl <- class(x)
	x <- x[fields]
	class(x) <- cl

#-------can add "biom" class if missing
	if(!("biom" %in% class(x))) {
		qwarning("not biom class")
		if(!fix) return(FALSE)
		class(x) <- c("biom", class(x))
	}

	if(!fix) return(TRUE)
	x
}

################################################################################
## retrieve from MG-RAST to build and save packaged examples:
##
## jtxt -- complete JSON text for BIOM object
## smat -- sparse matrix of data, represented in three columns
## dmat -- dense matrix, with row and column names
## li1 -- minimal list, with data given as dense matrix with dimnames
## li2 -- short list, data as above, but also with explicit row and column records
## li3 -- short list as above, but with data formatted as list of rows
## li4 -- complete list of BIOM components
################################################################################
build.examples <- function(outfile="examples.Rda") {
	library(RJSONIO)
	library(MGRASTer)
	message("Building ", outfile, " in: ", getwd())

#-------complete JSON text for BIOM object
	jtxt <- call.MGRAST('ma', 'or', id=c(4447943.3, 4447192.3, 4447102.3, 4447103.3), 
		gro='family', so='Ref', resu='ab', ev=15, parse=FALSE)

#-------complete list of BIOM elements
	li4 <- call.MGRAST('ma', 'or', id=c(4447943.3, 4447192.3, 4447102.3, 4447103.3), 
		gro='family', so='Ref', resu='ab', ev=15)
	li4 [c("matrix_element_value", "url")] <- NULL

#-------sparse matrix of data, represented in three columns
	smat <- t(simplify2array(li4$data))

#-------dense matrix, with row and column names
	dmat <- matrix(101:200, nrow=20, dimnames=list(letters[1:20], LETTERS[1:5]))

#-------minimal list, with data given as dense matrix with dimnames
#-------also, type will be partially-matched
	li1 <- list(
		data=dmat,
		type="OTU")

#-------short list, data as above, but also with explicit row and column records
	triple <- function (x) paste(x, x, x, sep="")
	li2 <- list(
		data = dmat,
		type = "OTU table",
		rows = lapply(triple(rownames(dmat)),
			function (x) c(id=x, metadata=paste("metadata of", x))),
		columns = lapply(triple(colnames(dmat)),
			function (x) c(id=x, metadata=paste("metadata of", x))))

#-------short list as above, but with data formatted as list of rows
	li3 <- list(
		data=lapply(apply(unname(dmat), 1, list), `[[`, 1),
		type="OTU table",
		rows=li2$rows,
		columns=li2$columns)

	save(smat, dmat, li1, li2, li3, li4, jtxt, file=outfile)
	message("Done.  Move to BIOM.utils/data")
}

################################################################################
## just run all methods on a (putative) biom object
################################################################################
test.object <- function (x) {
	str(x)
	as.character(x)
	as.matrix(x)
	as.matrix(x,force=FALSE)
	as.matrix(x,row=byid,col=byid)
	as.matrix(x,row=bymetadata,col=bymetadata)
	dim(x)
	len(x)
	dimnames(x)
	print(x)
	summary(x)
	is.biom(x)
	is.biom(x,fix=TRUE)
}
