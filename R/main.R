######################################################################################
## S3 implementation of BIOM format
## class(x) is c("list", "RBIOM")
##
## BIOM required components: 
## id, format, format_url, type, generated_by, date, rows, columns, matrix_type, matrix_element_type, shape, data
##
## BIOM optional components: 
## comment
##
## see: http://biom-format.org/documentation/format_versions/biom-1.0.html
## 
## package includes validation, conversion, and other utility methods
## small on purpose, no bloat
##
## considered "str.RBIOM" method, but it seems unnecessary
######################################################################################

.onAttach <- function (libname, pkgname) { 
	packageStartupMessage(pkgname, " (", packageVersion(pkgname), " build xxxxxxx)")
}

######################################################################################
## print it all
######################################################################################
print.RBIOM <- function (x, ...) {
print(as.matrix(x))
summary(x)
}

######################################################################################
## validate and print summary
######################################################################################
summary.RBIOM <- function (object, ...) { 
dd <- dim(x)
dds <- paste (dd[1], "x", dd[2], sep = "")
if (x$matrix_type == "sparse")
	dds <- paste (dds, ", ", length(x), " elements", sep = "")
cat(x$matrix_type, " ", x$type,  
	" (", dds, ") ",
	" (", x$format, ") ", x$id, "\n", sep ="")
cat("generated by ", x$generated_by, " on ", x$date, "\n", sep="")
}

######################################################################################
## shape of matrix (whether or not sparse)
######################################################################################
dim.RBIOM <- function(x)
	as.integer(unlist(x$shape))

######################################################################################
## returns length-2 list of rownames, colnames
## good to have methods for those functions, too
## but would be asking for trouble (for now) since they are not already generic
## ...whereas dimnames() is
######################################################################################
dimnames.RBIOM <- function(x, full=FALSE) {
if(full) {
	grab.name <- function (aa) 
		paste(as.character(unlist(aa$metadata)), collapse=",")
	list(sapply (x$rows, grab.name),
		sapply (x$columns, grab.name))
}
else
	list(sapply (x$rows, `[[`, i="id"),
		sapply (x$columns, `[[`, i="id"))
}

######################################################################################
## number of actually provided data elements (handled according to type)
######################################################################################
length.RBIOM <- function(x) {
if(x$matrix_type == "sparse")
	length(x$data)
else
	length(unlist(x$data))
}

######################################################################################
## convert to matrix
##-------would be good to use stats::reshape instead of Matrix::sparseMatrix
######################################################################################
as.matrix.RBIOM <- function(x, use.names = TRUE, force.dense=FALSE, ...) {
dd <- dim(x)
if (x$matrix_type == "sparse") {
	mm <- matrix (unlist(x$data), ncol=3, byrow=TRUE)
	mm <- Matrix::sparseMatrix (i=1+mm[,1], j=1+mm[,2], x=mm[,3], dims=dd)
	if (force.dense)
		mm <- as.matrix(mm)
}
else
	mm <- matrix (unlist (x$data), nrow=dd[1], ncol=dd[2], byrow=TRUE)
if(use.names)
	dimnames(mm) <- dimnames(x)
mm
}

######################################################################################
## convert to JSON text
##-------the use of toJSON() here needs some careful looking-over
######################################################################################
unlist.RBIOM <- function (x, ...)
	RJSONIO::toJSON(x, pretty=TRUE)

######################################################################################
## convert to JSON text, second way
######################################################################################
as.character.RBIOM <- unlist.RBIOM


######################################################################################
## CONSTRUCTORS
######################################################################################
RBIOM <- function (x, ...) UseMethod(RBIOM, x)

######################################################################################
## construct from list
######################################################################################
RBIOM.list <- function (x, ...) { 
class(x) <- c("RBIOM", class(x))
is.BIOM(x, fix=TRUE)
}

######################################################################################
## construct from matrix, inventing something for all fields appropriately
######################################################################################
RBIOM.matrix <- function (x, ...) {
#-------> SHOULD BE EASY 
#-------> ADD rows/cols HERE?
# make character.  make list.  populate minimum fields to make is.RBIOM(fix=TRUE) run
warning("matrix to biom is unimplemented")
}

######################################################################################
## construct from JSON text
##-------the use of fromJSON() here needs some careful looking-over
######################################################################################
RBIOM.character <- function (x, ...)
	RJSONIO::fromJSON(x, asText=TRUE, simplify=TRUE)


######################################################################################
## validate object
######################################################################################
is.RBIOM <- function (x, fix=FALSE, check.all=fix, quiet=!check.all) {
quiet.warning <- 
	(if(!quiet) warning
	else function(...) { })

if("package:biom" %in% search())
	warning("this package may conflict with package \"biom\", which is also loaded")

#-------must absolutely be "list" class already
if(!is.list(x)) {
	quiet.warning("object is not list")
	if(fix) stop("cannot fix")
	return(FALSE)
}
#-------can add "RBIOM" class if missing
if(!("RBIOM" %in% class(x))) {
	quiet.warning("not RBIOM class")
	if(!fix) return(FALSE)
	class(x) <- c("RBIOM", class(x))
}

#-------elements must have names
if(is.null(names(x))) {
	if(fix) stop("cannot fix object with missing names")
	quiet.warning("components are unnamed")
	return(FALSE)
}

fields <- c("id","format","format_url","type","generated_by","date","rows",
	"columns","matrix_type","matrix_element_type","shape","data")
fields.extra <- !(names(x) %in% fields)

#-------extra fields do not cause return(FALSE) but we do remove (below) if fix=TRUE
if(any(fields.extra))
	quiet.warning("contains unrecognized field(s): ", 
		paste(names(x)[fields.extra], collapse=" ", sep=""))

#-------missing fields can sometimes be fixed
fields.missing <- fields[!(fields %in% names(x))]
if(length(fields.missing)) {
	quiet.warning("required field(s) missing: ", 
		paste(fields.missing, collapse=" ", sep=""))
	if(!fix) return(FALSE)
#-------require the most basic info
	if(any(c("type","rows","columns","data") %in% fields.missing))
		stop("cannot fix")
#-------fill in trivial basic info
	if("id" %in% fields.missing) x$id <- "unknown"
	if("format" %in% fields.missing) x$format <- "unknown"
	if("format_url" %in% fields.missing) x$format_url <- "unknown"
	if("generated_by" %in% fields.missing) x$generated_by <- 
		paste("RBIOM", " (", packageVersion(pkgname), " build xxxxxxx)", sep="")
	if("date" %in% fields.missing) x$date <- date()
#-------remainder are inferred, below, when CV is checked
	if(any(c("matrix_type","matrix_element_type","shape") %in% missing))
		x$matrix_type <- x$matrix_element_type <- x$shape <- ""
}

#-------remove extra fields; order fields standardly; remove duplicate fields
x <- x[fields]

#-------check controlled vocabularies for "type"
if(! (x$type %in%
	c("OTU table","Pathway table","Function table","Ortholog table",
	"Gene table","Metabolite table","Taxon table"))) {
	quiet.warning("invalid \"type\": ", x$type)
	if (fix) stop("cannot fix")
	return(FALSE)
}
#-------a partial check that data description is complete and consistent
if(! (x$matrix_type %in% c("sparse","dense")) ||
	! (x$matrix_element_type %in% c("int", "float", "unicode"))) {
	quiet.warning("data description is non-conforming")
	if(!fix) return(FALSE)
	quiet.warning("inferring matrix type and shape")
#-------if not, infer matrix properties
	if(all(sapply(data,length)==3)) {
		quiet.warning("assuming three-column data is sparse without knowing")
		x$matrix_type <- "sparse"
		x$shape <- c(1+max(sapply(data,`[[`,1)), 1+max(sapply(data,`[[`,2)))
	}
	else {
		x$matrix_type <- "dense"
		x$shape <- c(length(data), length(data[[1]]))
	}
	x$matrix_element_type <- "unicode"
}

if(!check.all && !fix) return(TRUE)

#-------check consistency of data and shape


#-------check rows
zz <- !sapply(x$rows, function (row) metadata %in% names(row))
if(any(zz))
	quiet.warning("row(s) missing \"metadata\": ", which(zz))
zz <- !sapply(x$rows, function (row) id %in% names(row))
if(any(zz))
	quiet.warning("row(s) missing \"id\": ", which(zz))

#-------check columns
zz <- !sapply(x$columns, function (col) metadata %in% names(col))
if(any(zz))
	quiet.warning("column(s) missing \"metadata\": ", which(zz))
zz <- !sapply(x$columns, function (col) id %in% names(col))
if(any(zz))
	quiet.warning("column(s) missing \"id\": ", which(zz))
if(!fix) return(TRUE)
x
}
