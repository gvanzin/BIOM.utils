######################################################################################
## S3 implementation of BIOM format
## class(x) is c("list", "biom")
##
## BIOM required components: 
## id, format, format_url, type, generated_by, date, rows, columns, matrix_type, matrix_element_type, shape, data
##
## BIOM optional components: 
## comment
##
## see: http://biom-format.org/documentation/format_versions/biom-1.0.html
## 
## package includes validation, conversion, and other utility methods
## small on purpose, no bloat
##
## considered "str.biom" method, but it seems unnecessary
######################################################################################

.onAttach <- function (libname, pkgname) { 
	packageStartupMessage(pkgname, " (", packageVersion(pkgname), " build xxxxxxx)")
}

######################################################################################
## print it all
######################################################################################
print.biom <- function (x, ...) {
print(as.matrix(x))
summary(x)
}

######################################################################################
## validate and print summary
######################################################################################
summary.biom <- function (object, ...) { 
dd <- dim(object)
dds <- paste (dd[1], "x", dd[2], sep = "")
if (object$matrix_type == "sparse")
	dds <- paste (dds, ", ", len(object), " elements", sep = "")
cat(object$matrix_type, " ", object$type,  
	" (", dds, ") ",
	object$format, "\n",
	object$id, "\n", sep ="")
cat("generated by ", object$generated_by, " on ", object$date, "\n", sep="")
}

######################################################################################
## shape of matrix (whether or not sparse)
######################################################################################
dim.biom <- function(x)
	as.integer(unlist(x$shape))

######################################################################################
## returns length-2 list of rownames, colnames
## good to have methods for those functions, too
## but would be asking for trouble (for now) since they are not already generic
## ...whereas dimnames() is
## have to take a bit of trouble here since "id" may be character or list; we expect it to be length-one
######################################################################################
dimnames.biom <- function(x) {
	strip <- function (r) as.character(r["id"])[1]
	list(sapply (x$rows, strip),
		sapply (x$columns, strip))
}

######################################################################################
## number of actually provided data elements (handled according to type)
######################################################################################
len <- function(x) {
if(x$matrix_type == "sparse")
	length(x$data)
else
	length(unlist(x$data))
}

######################################################################################
## convert to matrix
##--->would be good to use stats::reshape instead of Matrix::sparseMatrix
## slightly different "strip" function here since we expect metadata to be a list
######################################################################################
as.matrix.biom <- function(x, alt.names=FALSE, force.dense=FALSE, ...) {
dd <- dim(x)
if (x$matrix_type == "sparse") {
	mm <- matrix (unlist(x$data), ncol=3, byrow=TRUE)
	mm <- Matrix::sparseMatrix (i=1+mm[,1], j=1+mm[,2], x=mm[,3], dims=dd)
	if (force.dense)
		mm <- as.matrix(mm)
} else
	mm <- matrix (unlist (x$data), nrow=dd[1], ncol=dd[2], byrow=TRUE)
alt.names <- rep_len(alt.names,2)
strip <- function (r) paste(unlist(r["metadata"]), collapse=",")
dimnames(mm) <- dimnames(x)
if(alt.names[1]) dimnames(mm)[[1]] <- sapply (x$rows, strip)
if(alt.names[2]) dimnames(mm)[[2]] <- sapply (x$columns, strip)
mm
}

######################################################################################
## convert to JSON text
##--->the use of toJSON() here needs some careful looking-over
######################################################################################
as.character.biom <- function (x, ...)
	RJSONIO::toJSON(x, pretty=TRUE, ...)



######################################################################################
## CONSTRUCTORS
######################################################################################
biom <- function (x, ...) UseMethod("biom")

######################################################################################
## construct from list
######################################################################################
biom.list <- function (x, ...) { 
class(x) <- c("biom", class(x))
is.biom(x, fix=TRUE)
}

######################################################################################
## construct from matrix, inventing something for all fields appropriately
##--->maybe not unicode
##--->use row/colnames of matrix if present!
######################################################################################
biom.matrix <- function (x, 
	type = c("OTU table","Pathway table","Function table","Ortholog table",
		"Gene table","Metabolite table","Taxon table"), ...) {
if(missing(type))
	warning("it\'s bad that parameter \"type\" is unspecified")
y <- list()
y$type <- match.arg(type)
y$data <- apply(x, 1, as.list)
y$rows <- rep(list(c(id="", metadata="")),nrow(x))
y$columns <- rep(list(c(id="", metadata="")),ncol(x))
y$matrix_type <- "dense"
y$matrix_element_type <- "unicode"
y$shape <- dim(x)
is.biom(y,fix=TRUE,quiet=TRUE)
}

######################################################################################
## construct from JSON text
##--->the use of fromJSON() here needs some careful looking-over
######################################################################################
biom.character <- function (x, ...)
	biom(RJSONIO::fromJSON(x, asText=TRUE, simplify=TRUE))


######################################################################################
## validate object
##--->shape should be integer, character, or list??
##--->should check matrix_element_type
######################################################################################
is.biom <- function (x, fix=FALSE, check.all=fix, quiet=!check.all) {
quiet.warning <- 
	(if(!quiet) warning
	else function(...) { })

if("package:biom" %in% search())
	warning("this package may conflict with package \"biom\", which is also loaded")

#-------must absolutely be "list" class already
if(!is.list(x)) {
	quiet.warning("object is not list")
	if(fix) stop("cannot fix")
	return(FALSE)
}
#-------can add "biom" class if missing
if(!("biom" %in% class(x))) {
	quiet.warning("not biom class")
	if(!fix) return(FALSE)
	class(x) <- c("biom", class(x))
}

#-------elements must have names
if(is.null(names(x))) {
	if(fix) stop("cannot fix object with missing names")
	quiet.warning("components are unnamed")
	return(FALSE)
}

fields <- c("id","format","format_url","type","generated_by","date","rows",
	"columns","matrix_type","matrix_element_type","shape","data")
fields.extra <- !(names(x) %in% fields)

#-------extra fields do not cause return(FALSE) but we do remove (below) if fix=TRUE
if(any(fields.extra))
	quiet.warning("contains unrecognized field(s): ", 
		paste(names(x)[fields.extra], collapse=" ", sep=""))

#-------missing fields can sometimes be fixed
fields.missing <- fields[!(fields %in% names(x))]
if(length(fields.missing)) {
	quiet.warning("required field(s) missing: ", 
		paste(fields.missing, collapse=" ", sep=""))
	if(!fix) return(FALSE)
#-------require the most basic info
	if(any(c("type","rows","columns","data") %in% fields.missing))
		stop("cannot fix")
#-------fill in trivial basic info
	if("id" %in% fields.missing) x$id <- "unknown id"
	if("format" %in% fields.missing) x$format <- "unknown BIOM format"
	if("format_url" %in% fields.missing) x$format_url <- "unknown format_url"
	if("generated_by" %in% fields.missing) x$generated_by <- 
#-------DON'T LIKE THIS:
		paste("BIOM.utils", " (", packageVersion("BIOM.utils"), " build xxxxxxx)", sep="")
#-------this is probably the wrong date format
	if("date" %in% fields.missing) x$date <- date()
#-------remainder are inferred, below, when CV is checked
	if(any(c("matrix_type","matrix_element_type","shape") %in% fields.missing))
		x$matrix_type <- x$matrix_element_type <- x$shape <- ""
}

#-------remove extra fields; order fields standardly; remove duplicate fields
cc <- class(x)
x <- x[fields]
class(x) <- cc

#-------check controlled vocabularies for "type"
if(! (x$type %in%
	c("OTU table","Pathway table","Function table","Ortholog table",
	"Gene table","Metabolite table","Taxon table"))) {
	quiet.warning("invalid \"type\": ", x$type)
	if (fix) stop("cannot fix")
	return(FALSE)
}
#-------a partial check that data description is complete and consistent
if(! (x$matrix_type %in% c("sparse","dense")) ||
	! (x$matrix_element_type %in% c("int", "float", "unicode"))) {
	quiet.warning("data description is non-conforming")
	if(!fix) return(FALSE)
	quiet.warning("inferring matrix type and shape")
#-------if not, infer matrix properties
	if(all(sapply(data,length)==3)) {
		quiet.warning("assuming three-column data is sparse without knowing")
		x$matrix_type <- "sparse"
		x$shape <- c(1+max(sapply(data,`[[`,1)), 1+max(sapply(data,`[[`,2)))
	}
	else {
		x$matrix_type <- "dense"
		x$shape <- c(length(x$data), length(x$data[[1]]))
	}
	x$matrix_element_type <- "unicode"
}

#-------here marks the separation between a "short" and "long"  conformity check
if(!check.all && !fix) return(TRUE)

#-------check consistency of data and shape
if(x$matrix_type == "dense") {
	ll <- length(x$data[[1]])
	if(!all(sapply(x$data,length)==ll)) {
		quiet.warning("non-uniform row lengths in dense matrix")
		if(fix) stop("cannot fix")
		return(FALSE)
	}
	if(!identical(x$shape, c(length(x$data), ll))) {
		quiet.warning("wrong shape for dense matrix")
		if(!fix) return(FALSE)
		x$shape <- c(length(x$data), ll)
	}
}
else {
	if(!all(sapply(x$data,length)==3)) {
		quiet.warning("row lengths in sparse matrix not all three")
		if(fix) stop("cannot fix")
		return(FALSE)
	}
	maxrow <- max(sapply(x$data,`[[`,1))
	maxcol <- max(sapply(x$data,`[[`,2))
	if(x$shape[[1]] < maxrow ||
		x$shape[[2]] < maxcol) {
		quiet.warning("wrong shape for sparse matrix")
		if(!fix) return(FALSE)
		x$shape <- c(1+maxrow, 1+maxcol)
	}
}

#-------check rows
zz <- !sapply(x$rows, function (row) "metadata" %in% names(row))
if(any(zz)) {
	quiet.warning("row(s) missing \"metadata\": ", which(zz))
	if(!fix) return(FALSE)
	x$rows[zz] <- lapply(x$rows[zz], `[[<-`, "metadata", "unknown")
}
zz <- !sapply(x$rows, function (row) "id" %in% names(row))
if(any(zz)) {
	quiet.warning("row(s) missing \"id\": ", which(zz))
	if(!fix) return(FALSE)
	x$rows[zz] <- lapply(x$rows[zz], `[[<-`, "id", "unknown")
}
#-------check columns
zz <- !sapply(x$columns, function (col) "metadata" %in% names(col))
if(any(zz)) {
	quiet.warning("column(s) missing \"metadata\": ", which(zz))
	if(!fix) return(FALSE)	
	x$columns[zz] <- lapply(x$columns[zz], `[[<-`, "metadata", "unknown")
}
zz <- !sapply(x$columns, function (col) "id" %in% names(col))
if(any(zz)) {
	quiet.warning("column(s) missing \"id\": ", which(zz))
	if(!fix) return(FALSE)
	x$columns[zz] <- lapply(x$columns[zz], `[[<-`, "id", "unknown")
}
if(!fix) return(TRUE)
x
}
